{
  "name": "WF-01 Fetch Gaming Clubs",
  "nodes": [
    {
      "id": "exec-trigger-001",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [260, 400],
      "parameters": {}
    },
    {
      "id": "manual-trigger-001",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [260, 500],
      "parameters": {}
    },
    {
      "id": "schedule-trigger-001",
      "name": "Daily Schedule",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [260, 600],
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "custom",
              "cronExpression": "0 3 * * *"
            }
          ]
        }
      }
    },
    {
      "id": "merge-triggers-001",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [460, 500],
      "parameters": {
        "mode": "combine",
        "combinationMode": "chooseBranch",
        "options": {}
      }
    },
    {
      "id": "prepare-search-data-001",
      "name": "Prepare Search Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [660, 500],
      "parameters": {
        "functionCode": "// Prepare search parameters\nlet searchData;\n\n// From orchestrator\nif ($json.city && $json.runId) {\n  searchData = {\n    city: $json.city,\n    region: $json.region || '',\n    city_id_2gis: $json.cityId2gis || $json.city_id_2gis || '',\n    query: $json.query || 'компьютерный клуб киберспорт',\n    runId: $json.runId,\n    wave: $json.wave || 1,\n    lat: $json.lat,\n    lon: $json.lon\n  };\n} \n// Manual trigger with custom city\nelse if ($json.city) {\n  searchData = {\n    city: $json.city,\n    region: $json.region || '',\n    city_id_2gis: $json.city_id_2gis || '',\n    query: $json.query || 'компьютерный клуб киберспорт',\n    runId: `manual_${Date.now()}`,\n    wave: 0\n  };\n} \n// Default schedule run\nelse {\n  // Get cities from Redis queue or use default\n  searchData = {\n    city: 'Москва',\n    region: 'Московская область',\n    query: 'компьютерный клуб киберспорт',\n    runId: `schedule_${Date.now()}`,\n    wave: 0\n  };\n}\n\nconst startTime = Date.now();\nconsole.log(`Starting search for ${searchData.city} (runId: ${searchData.runId})`);\n\nreturn [{ \n  json: {\n    ...searchData,\n    startTime\n  } \n}];"
      }
    },
    {
      "id": "wait-initial-001",
      "name": "Initial Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [860, 500],
      "parameters": {
        "amount": 1,
        "unit": "seconds"
      }
    },
    {
      "id": "fetch-yandex-001",
      "name": "Fetch Yandex Maps",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1060, 400],
      "parameters": {
        "method": "GET",
        "url": "https://search-maps.yandex.ru/v1/",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.query + ' ' + $json.city }}"
            },
            {
              "name": "type",
              "value": "biz"
            },
            {
              "name": "lang",
              "value": "ru_RU"
            },
            {
              "name": "results",
              "value": "50"
            },
            
          ]
        },
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "continueOnFail": true
    },
    {
      "id": "fetch-2gis-001",
      "name": "Fetch 2GIS",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1060, 600],
      "parameters": {
        "method": "GET",
        "url": "https://catalog.api.2gis.com/3.0/items",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "q",
              "value": "={{ $json.query }}"
            },
            {
              "name": "type",
              "value": "branch"
            },
            {
              "name": "page_size",
              "value": "50"
            },
            {
              "name": "page",
              "value": "1"
            },
            {
              "name": "fields",
              "value": "items.contact_groups,items.point,items.address_name,items.org,items.rubrics"
            },
            
            {
              "name": "city_id",
              "value": "={{ $json.city_id_2gis || '' }}"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "continueOnFail": true
    },
    {
      "id": "merge-api-results-001",
      "name": "Merge API Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [1260, 500],
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": [
            {
              "field1": "city",
              "field2": "city"
            }
          ]
        },
        "joinMode": "enrichInput1",
        "options": {}
      }
    },
    {
      "id": "parse-results-001",
      "name": "Parse Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1460, 500],
      "parameters": {
        "functionCode": "const searchData = $node['Prepare Search Data'].json;\nconst yandexResponse = $node['Fetch Yandex Maps'].json;\nconst twoGisResponse = $node['Fetch 2GIS'].json;\n\nconst clubs = [];\nconst errors = [];\n\n// Parse Yandex results\nif (yandexResponse?.statusCode === 200 && yandexResponse?.body?.features) {\n  for (const feature of yandexResponse.body.features) {\n    const props = feature.properties || {};\n    const meta = props.CompanyMetaData || {};\n    const phones = (meta.Phones || []).map(p => p.formatted).filter(Boolean);\n    \n    if (props.name && props.address) {\n      clubs.push({\n        name: props.name,\n        address: props.address.formatted || '',\n        phone: phones[0] || '',\n        additionalPhones: phones.slice(1),\n        city: searchData.city,\n        region: searchData.region,\n        source: 'YandexMaps',\n        coordinates: {\n          lat: feature.geometry?.coordinates?.[1] || 0,\n          lon: feature.geometry?.coordinates?.[0] || 0\n        },\n        url: meta.url || '',\n        workingHours: meta.Hours?.text || '',\n        categories: (meta.Categories || []).map(c => c.name).join(', '),\n        foundAt: new Date().toISOString(),\n        runId: searchData.runId\n      });\n    }\n  }\n} else {\n  errors.push({\n    api: 'YandexMaps',\n    status: yandexResponse?.statusCode || 'No response',\n    error: yandexResponse?.body?.message || 'Failed to fetch data'\n  });\n}\n\n// Parse 2GIS results  \nif (twoGisResponse?.statusCode === 200 && twoGisResponse?.body?.result?.items) {\n  for (const item of twoGisResponse.body.result.items) {\n    const contacts = {};\n    \n    // Extract contacts\n    for (const group of (item.contact_groups || [])) {\n      for (const contact of (group.contacts || [])) {\n        if (!contacts[contact.type]) {\n          contacts[contact.type] = [];\n        }\n        contacts[contact.type].push(contact.value);\n      }\n    }\n    \n    if (item.name && item.address_name) {\n      clubs.push({\n        name: item.name,\n        address: item.address_name,\n        phone: (contacts.phone || [])[0] || '',\n        additionalPhones: (contacts.phone || []).slice(1),\n        email: (contacts.email || [])[0] || '',\n        city: searchData.city,\n        region: searchData.region,\n        source: '2GIS',\n        isChain: (item.org?.branch_count || 0) > 1,\n        brand: item.org?.name || '',\n        branchCount: item.org?.branch_count || 1,\n        coordinates: {\n          lat: item.point?.lat || 0,\n          lon: item.point?.lon || 0\n        },\n        url: (contacts.website || [])[0] || '',\n        telegram: (contacts.telegram || [])[0] || '',\n        rubrics: (item.rubrics || []).map(r => r.name).join(', '),\n        foundAt: new Date().toISOString(),\n        runId: searchData.runId\n      });\n    }\n  }\n} else if (twoGisResponse?.statusCode === 429) {\n  errors.push({\n    api: '2GIS',\n    status: 429,\n    error: 'Rate limit exceeded',\n    retryAfter: twoGisResponse.headers?.['retry-after'] || 60\n  });\n} else {\n  errors.push({\n    api: '2GIS',\n    status: twoGisResponse?.statusCode || 'No response',\n    error: twoGisResponse?.body?.error?.message || 'Failed to fetch data'\n  });\n}\n\n// Deduplicate\nconst uniqueClubs = [];\nconst seen = new Set();\n\nfor (const club of clubs) {\n  const key = `${club.name.toLowerCase().trim()}_${club.address.toLowerCase().trim()}`;\n  if (!seen.has(key)) {\n    seen.add(key);\n    uniqueClubs.push(club);\n  }\n}\n\nconst elapsedMs = Date.now() - searchData.startTime;\nconsole.log(`Found ${uniqueClubs.length} unique clubs in ${searchData.city} (${elapsedMs}ms)`);\n\nreturn [{\n  json: {\n    city: searchData.city,\n    runId: searchData.runId,\n    clubs: uniqueClubs,\n    clubsFound: uniqueClubs.length,\n    errors,\n    elapsedMs,\n    timestamp: new Date().toISOString()\n  }\n}];"
      }
    },
    {
      "id": "check-results-001",
      "name": "Check Results",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1660, 500],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "hasClubs",
              "leftValue": "={{ $json.clubsFound }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "prepare-batch-save-001",
      "name": "Prepare Batch Save",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1860, 400],
      "parameters": {
        "functionCode": "const result = items[0].json;\nconst clubs = result.clubs;\nconst operations = [];\n\n// Save each club to Redis Set for deduplication\nfor (const club of clubs) {\n  const clubKey = `${club.city.replace(/\\s+/g, '_')}:${club.name.replace(/[^a-zA-Z0-9А-Яа-я]/g, '_')}`;\n  \n  operations.push({\n    operation: 'sadd',\n    key: 'raw_clubs',\n    value: clubKey\n  });\n  \n  operations.push({\n    operation: 'set',\n    key: `club:${clubKey}`,\n    value: JSON.stringify(club),\n    ttl: 30 * 24 * 60 * 60\n  });\n}\n\n// Save result summary\noperations.push({\n  operation: 'set',\n  key: `result:${result.runId}:${result.city}`,\n  value: JSON.stringify({\n    city: result.city,\n    clubsFound: result.clubsFound,\n    errors: result.errors,\n    timestamp: result.timestamp\n  }),\n  ttl: 7 * 24 * 60 * 60\n});\n\nreturn operations.map(op => ({ json: op }));"
      }
    },
    {
      "id": "split-operations-001",
      "name": "Split Operations",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [2060, 400],
      "parameters": {
        "batchSize": 10,
        "options": {}
      }
    },
    {
      "id": "handle-operations-001",
      "name": "Handle Operations",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2260, 400],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "isSadd",
              "leftValue": "={{ $json.operation }}",
              "rightValue": "sadd",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "redis-sadd-001",
      "name": "Redis Set Add",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2460, 300],
      "parameters": {
        "operation": "add",
        "keyType": "set",
        "key": "={{ $json.key }}",
        "value": "={{ $json.value }}"
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    },
    {
      "id": "redis-set-001",
      "name": "Redis Set Value",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2460, 500],
      "parameters": {
        "operation": "set",
        "key": "={{ $json.key }}",
        "value": "={{ $json.value }}",
        "expire": "={{ !!$json.ttl }}",
        "ttl": "={{ $json.ttl || 86400 }}"
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    },
    {
      "id": "merge-save-001",
      "name": "Merge Save Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [2660, 400],
      "parameters": {
        "mode": "combine",
        "combinationMode": "multiplex",
        "options": {}
      }
    },
    {
      "id": "trigger-enrichment-001",
      "name": "Trigger Enrichment",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2860, 400],
      "parameters": {
        "functionCode": "// Get clubs from the parse results\nconst result = $node['Parse Results'].json;\nconst enrichmentTasks = [];\n\n// Create enrichment tasks for high-priority clubs\nfor (const club of result.clubs) {\n  // Prioritize chains and clubs with websites\n  if (club.isChain || club.url || club.branchCount > 1) {\n    enrichmentTasks.push({\n      workflow: 'WF-02',\n      club: club,\n      runId: result.runId\n    });\n  }\n}\n\nconsole.log(`Triggering enrichment for ${enrichmentTasks.length} high-priority clubs`);\n\nreturn enrichmentTasks.length > 0 ? enrichmentTasks : [{ json: { skipped: true } }];"
      }
    },
    {
      "id": "exec-wf02-001",
      "name": "Execute WF-02",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [3060, 400],
      "parameters": {
        "source": "database",
        "workflowId": "={{ $env.WF_02_WORKFLOW_ID }}",
        "waitForSubWorkflow": false
      },
      "continueOnFail": true
    },
    {
      "id": "no-results-001",
      "name": "No Results Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1860, 600],
      "parameters": {
        "functionCode": "const city = $json.city;\nconst errors = $json.errors;\n\nconsole.log(`No clubs found in ${city}. Errors:`, errors);\n\nreturn [{\n  json: {\n    city: city,\n    clubsFound: 0,\n    message: 'No gaming clubs found',\n    errors: errors,\n    runId: $json.runId,\n    timestamp: new Date().toISOString()\n  }\n}];"
      }
    },
    {
      "id": "complete-001",
      "name": "Complete Workflow",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [3260, 500],
      "parameters": {
        "functionCode": "// Return final results for the executeWorkflow trigger\nconst parseResults = $node['Parse Results'].json;\n\nconst output = {\n  success: true,\n  city: parseResults.city,\n  clubsFound: parseResults.clubsFound,\n  runId: parseResults.runId,\n  timestamp: parseResults.timestamp,\n  elapsedMs: parseResults.elapsedMs\n};\n\nconsole.log(`WF-01 completed for ${output.city}: ${output.clubsFound} clubs found`);\n\n// Return data for parent workflow\nreturn [{ json: output }];"
      }
    },
    {
      "id": "error-trigger-001",
      "name": "Error Trigger",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [260, 800],
      "parameters": {}
    },
    {
      "id": "handle-error-001",
      "name": "Handle Error",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [460, 800],
      "parameters": {
        "functionCode": "const searchData = $node['Prepare Search Data']?.json || {};\n\nconst error = {\n  workflow: 'WF-01 Fetch Gaming Clubs',\n  city: searchData.city || 'Unknown',\n  runId: searchData.runId || 'Unknown',\n  timestamp: new Date().toISOString(),\n  error: $json.error?.message || 'Unknown error',\n  node: $json.error?.node?.name || 'Unknown',\n  stack: $json.error?.stack\n};\n\nconsole.error('WF-01 Error:', error);\n\nreturn [{ json: error }];"
      }
    },
    {
      "id": "save-error-001",
      "name": "Save Error",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [660, 800],
      "parameters": {
        "operation": "push",
        "list": "errors:fetch",
        "messageData": "={{ JSON.stringify($json) }}",
        "pushType": "lpush",
        "expire": true,
        "ttl": 86400
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    },
    {
      "id": "error-notification-001",
      "name": "Error Notification",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [860, 800],
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{ $env.TELEGRAM_ADMIN_CHAT_ID }}",
        "text": "={{ `❌ <b>WF-01 Error</b>\\n\\n🏙 City: ${$json.city}\\n🔴 Error: ${$json.error}\\n📍 Node: ${$json.node}\\n🆔 RunID: <code>${$json.runId}</code>` }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "credentials": {
        "telegramApi": {
          "id": "TELEGRAM_BOT",
          "name": "Telegram Bot"
        }
      }
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [[{"node": "Merge Triggers", "type": "main", "index": 0}]]
    },
    "Manual Trigger": {
      "main": [[{"node": "Merge Triggers", "type": "main", "index": 1}]]
    },
    "Daily Schedule": {
      "main": [[{"node": "Merge Triggers", "type": "main", "index": 2}]]
    },
    "Merge Triggers": {
      "main": [[{"node": "Prepare Search Data", "type": "main", "index": 0}]]
    },
    "Prepare Search Data": {
      "main": [[{"node": "Initial Rate Limit", "type": "main", "index": 0}]]
    },
    "Initial Rate Limit": {
      "main": [[
        {"node": "Fetch Yandex Maps", "type": "main", "index": 0},
        {"node": "Fetch 2GIS", "type": "main", "index": 0}
      ]]
    },
    "Fetch Yandex Maps": {
      "main": [[{"node": "Merge API Results", "type": "main", "index": 0}]]
    },
    "Fetch 2GIS": {
      "main": [[{"node": "Merge API Results", "type": "main", "index": 1}]]
    },
    "Merge API Results": {
      "main": [[{"node": "Parse Results", "type": "main", "index": 0}]]
    },
    "Parse Results": {
      "main": [[{"node": "Check Results", "type": "main", "index": 0}]]
    },
    "Check Results": {
      "main": [
        [{"node": "Prepare Batch Save", "type": "main", "index": 0}],
        [{"node": "No Results Handler", "type": "main", "index": 0}]
      ]
    },
    "Prepare Batch Save": {
      "main": [[{"node": "Split Operations", "type": "main", "index": 0}]]
    },
    "Split Operations": {
      "main": [
        [{"node": "Handle Operations", "type": "main", "index": 0}],
        [{"node": "Trigger Enrichment", "type": "main", "index": 0}]
      ]
    },
    "Handle Operations": {
      "main": [
        [{"node": "Redis Set Add", "type": "main", "index": 0}],
        [{"node": "Redis Set Value", "type": "main", "index": 0}]
      ]
    },
    "Redis Set Add": {
      "main": [[{"node": "Merge Save Results", "type": "main", "index": 0}]]
    },
    "Redis Set Value": {
      "main": [[{"node": "Merge Save Results", "type": "main", "index": 1}]]
    },
    "Merge Save Results": {
      "main": [[{"node": "Split Operations", "type": "main", "index": 0}]]
    },
    "Trigger Enrichment": {
      "main": [[{"node": "Execute WF-02", "type": "main", "index": 0}]]
    },
    "Execute WF-02": {
      "main": [[{"node": "Complete Workflow", "type": "main", "index": 0}]]
    },
    "No Results Handler": {
      "main": [[{"node": "Complete Workflow", "type": "main", "index": 0}]]
    },
    "Error Trigger": {
      "main": [[{"node": "Handle Error", "type": "main", "index": 0}]]
    },
    "Handle Error": {
      "main": [[{"node": "Save Error", "type": "main", "index": 0}]]
    },
    "Save Error": {
      "main": [[{"node": "Error Notification", "type": "main", "index": 0}]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "executionTimeout": 300,
    "timezone": "Europe/Moscow"
  },
  "version": 2,
  "id": "wf-01-fetch-gaming-clubs",
  "meta": {
    "templateCredsSetupCompleted": true,
    "description": "Fetches gaming clubs from Yandex and 2GIS with proper triggers, correct Redis operations, and data return for parent workflow",
    "version": "1.0.0"
  },
  "tags": [
    {
      "id": "1",
      "name": "production"
    },
    {
      "id": "3",
      "name": "parser"
    }
  ]
}