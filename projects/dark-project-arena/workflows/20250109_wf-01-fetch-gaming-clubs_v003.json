{
  "name": "WF-01 Fetch Gaming Clubs",
  "nodes": [
    {
      "id": "redis-queue-trigger-001",
      "name": "Redis Queue Trigger",
      "type": "n8n-nodes-base.redisTrigger",
      "typeVersion": 1,
      "position": [260, 400],
      "parameters": {
        "triggerMode": "listPop",
        "listKey": "queue:gaming_clubs:tasks",
        "operation": "leftPop",
        "jsonParseBody": true
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    },
    {
      "id": "manual-trigger-001",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [260, 600],
      "parameters": {}
    },
    {
      "id": "merge-triggers-001",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [460, 500],
      "parameters": {
        "mode": "combine",
        "combinationMode": "chooseBranch",
        "options": {}
      }
    },
    {
      "id": "parse-task-data-001",
      "name": "Parse Task Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [660, 500],
      "parameters": {
        "functionCode": "// Обрабатываем данные из очереди или manual trigger\nlet taskData;\n\nif (typeof $json === 'string') {\n  // Данные из Redis\n  try {\n    taskData = JSON.parse($json);\n  } catch (e) {\n    throw new Error('Failed to parse task data from Redis');\n  }\n} else if ($json.data) {\n  // Структурированные данные из очереди\n  taskData = $json;\n} else {\n  // Manual trigger - создаем задачу\n  taskData = {\n    taskId: `manual_${Date.now()}`,\n    type: 'FETCH_GAMING_CLUBS',\n    data: {\n      city: $json.city || 'Москва',\n      region: $json.region || 'Московская область',\n      runId: `manual_${Date.now()}`,\n      query: $json.query || 'компьютерный клуб киберспорт'\n    },\n    retries: 0,\n    maxRetries: 3\n  };\n}\n\nconst startTime = Date.now();\nconsole.log(`Processing task ${taskData.taskId} for city: ${taskData.data.city}`);\n\nreturn [{ \n  json: {\n    ...taskData,\n    startTime,\n    searchQuery: taskData.data.query || 'компьютерный клуб киберспорт'\n  }\n}];"
      }
    },
    {
      "id": "set-retry-context-001",
      "name": "Set Retry Context",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [860, 300],
      "parameters": {
        "content": "## Retry Logic\nEach API call has:\n- 3 retries with exponential backoff\n- Rate limit handling (429)\n- Error logging to Redis\n- Fallback to continue on API failure",
        "height": 150,
        "width": 300
      }
    },
    {
      "id": "wait-initial-001",
      "name": "Initial Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [860, 500],
      "parameters": {
        "amount": "={{ Math.random() * 2 + 0.5 }}",
        "unit": "seconds"
      }
    },
    {
      "id": "http-yandex-001",
      "name": "Fetch Yandex Maps",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1060, 400],
      "parameters": {
        "method": "GET",
        "url": "https://search-maps.yandex.ru/v1/",
        "authentication": "none",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.searchQuery + ' ' + $json.data.city }}"
            },
            {
              "name": "type",
              "value": "biz"
            },
            {
              "name": "lang",
              "value": "ru_RU"
            },
            {
              "name": "results",
              "value": "50"
            },
            {
              "name": "apikey",
              "value": "={{ $env.YANDEX_MAPS_API_KEY }}"
            }
          ]
        },
        "options": { 
          "timeout": 30000,
          "response": {
            "response": {
              "fullResponse": true,
              "neverError": true
            }
          }
        }
      },
      "continueOnFail": true
    },
    {
      "id": "prepare-2gis-request-001",
      "name": "Prepare 2GIS Request",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [1060, 600],
      "parameters": {
        "mode": "manual",
        "duplicateItem": false,
        "assignments": {
          "assignments": [
            {
              "id": "page",
              "name": "page",
              "type": "number",
              "value": 1
            },
            {
              "id": "hasMore",
              "name": "hasMore",
              "type": "boolean",
              "value": true
            },
            {
              "id": "allItems",
              "name": "allItems",
              "type": "array",
              "value": "[]"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      }
    },
    {
      "id": "2gis-pagination-loop-001",
      "name": "2GIS Pagination Loop",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1260, 600],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "hasMore",
              "leftValue": "={{ $json.hasMore }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            },
            {
              "id": "maxPages",
              "leftValue": "={{ $json.page }}",
              "rightValue": 5,
              "operator": {
                "type": "number",
                "operation": "smallerEqual"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "http-2gis-001",
      "name": "Fetch 2GIS Page",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1460, 500],
      "parameters": {
        "method": "GET",
        "url": "https://catalog.api.2gis.com/3.0/items",
        "authentication": "none",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "q",
              "value": "={{ $json.searchQuery }}"
            },
            {
              "name": "type",
              "value": "branch"
            },
            {
              "name": "page_size",
              "value": "50"
            },
            {
              "name": "page",
              "value": "={{ $json.page }}"
            },
            {
              "name": "fields",
              "value": "items.contact_groups,items.point,items.address_name,items.org,items.rubrics"
            },
            {
              "name": "key",
              "value": "={{ $env.TWOGIS_API_KEY }}"
            },
            {
              "name": "city_id",
              "value": "={{ $json.data.city_id_2gis || '' }}"
            }
          ]
        },
        "options": { 
          "timeout": 30000,
          "response": {
            "response": {
              "fullResponse": true,
              "neverError": true
            }
          }
        }
      },
      "continueOnFail": true
    },
    {
      "id": "process-2gis-response-001",
      "name": "Process 2GIS Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1660, 500],
      "parameters": {
        "functionCode": "const response = items[0].json;\nconst prevData = $node['2GIS Pagination Loop'].json;\n\n// Check for rate limit\nif (response.statusCode === 429) {\n  const retryAfter = response.headers?.['retry-after'] || 60;\n  console.log(`2GIS rate limited. Retry after ${retryAfter}s`);\n  \n  // Return with retry flag\n  return [{\n    json: {\n      ...prevData,\n      rateLimited: true,\n      retryAfter,\n      hasMore: true\n    }\n  }];\n}\n\n// Check for successful response\nif (response.statusCode !== 200 || !response.body?.result) {\n  console.error(`2GIS API error: ${response.statusCode}`);\n  return [{\n    json: {\n      ...prevData,\n      hasMore: false,\n      error: `API returned ${response.statusCode}`\n    }\n  }];\n}\n\n// Process successful response\nconst result = response.body.result;\nconst newItems = result.items || [];\nconst total = result.total || 0;\nconst currentPage = prevData.page;\nconst pageSize = 50;\n\n// Accumulate items\nconst allItems = [...(prevData.allItems || []), ...newItems];\n\n// Check if we have more pages\nconst hasMore = (currentPage * pageSize) < total && newItems.length > 0;\n\nreturn [{\n  json: {\n    ...prevData,\n    page: currentPage + 1,\n    hasMore,\n    allItems,\n    total,\n    rateLimited: false\n  }\n}];"
      }
    },
    {
      "id": "wait-2gis-rate-limit-001",
      "name": "Wait Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [1860, 500],
      "parameters": {
        "amount": "={{ $json.rateLimited ? Math.min($json.retryAfter || 60, 120) : 1 }}",
        "unit": "seconds"
      }
    },
    {
      "id": "merge-all-results-001",
      "name": "Merge All Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [1860, 700],
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": [
            {
              "field1": "taskId",
              "field2": "taskId"
            }
          ]
        },
        "joinMode": "enrichInput2",
        "options": {}
      }
    },
    {
      "id": "parse-all-results-001",
      "name": "Parse All Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2060, 700],
      "parameters": {
        "functionCode": "const taskData = $node['Parse Task Data'].json;\nconst yandexResponse = $node['Fetch Yandex Maps'].json;\nconst twoGisData = $node['2GIS Pagination Loop'].json;\n\nconst clubs = [];\nconst errors = [];\n\n// Parse Yandex results\nif (yandexResponse?.statusCode === 200 && yandexResponse?.body?.features) {\n  for (const feature of yandexResponse.body.features) {\n    const props = feature.properties || {};\n    const meta = props.CompanyMetaData || {};\n    const phones = (meta.Phones || []).map(p => p.formatted).filter(Boolean);\n    \n    clubs.push({\n      name: props.name || '',\n      address: props.address?.formatted || '',\n      phone: phones[0] || '',\n      additionalPhones: phones.slice(1),\n      city: taskData.data.city,\n      region: taskData.data.region,\n      source: 'YandexMaps',\n      coordinates: {\n        lat: feature.geometry?.coordinates?.[1] || 0,\n        lon: feature.geometry?.coordinates?.[0] || 0\n      },\n      url: meta.url || '',\n      workingHours: meta.Hours?.text || '',\n      categories: (meta.Categories || []).map(c => c.name).join(', '),\n      foundAt: new Date().toISOString(),\n      runId: taskData.data.runId,\n      taskId: taskData.taskId\n    });\n  }\n} else {\n  errors.push({\n    api: 'YandexMaps',\n    status: yandexResponse?.statusCode || 'No response',\n    error: yandexResponse?.body?.error || 'Unknown error'\n  });\n}\n\n// Parse 2GIS results\nif (twoGisData?.allItems && Array.isArray(twoGisData.allItems)) {\n  for (const item of twoGisData.allItems) {\n    const contacts = {};\n    \n    // Extract contacts\n    for (const group of (item.contact_groups || [])) {\n      for (const contact of (group.contacts || [])) {\n        if (!contacts[contact.type]) {\n          contacts[contact.type] = [];\n        }\n        contacts[contact.type].push(contact.value);\n      }\n    }\n    \n    clubs.push({\n      name: item.name || '',\n      address: item.address_name || '',\n      phone: (contacts.phone || [])[0] || '',\n      additionalPhones: (contacts.phone || []).slice(1),\n      email: (contacts.email || [])[0] || '',\n      city: taskData.data.city,\n      region: taskData.data.region,\n      source: '2GIS',\n      isChain: (item.org?.branch_count || 0) > 1,\n      brand: item.org?.name || '',\n      branchCount: item.org?.branch_count || 1,\n      coordinates: {\n        lat: item.point?.lat || 0,\n        lon: item.point?.lon || 0\n      },\n      url: (contacts.website || [])[0] || '',\n      telegram: (contacts.telegram || [])[0] || '',\n      rubrics: (item.rubrics || []).map(r => r.name).join(', '),\n      foundAt: new Date().toISOString(),\n      runId: taskData.data.runId,\n      taskId: taskData.taskId\n    });\n  }\n} else if (twoGisData?.error) {\n  errors.push({\n    api: '2GIS',\n    error: twoGisData.error\n  });\n}\n\n// Deduplicate by name+address\nconst uniqueClubs = [];\nconst seen = new Set();\n\nfor (const club of clubs) {\n  if (club.name && club.address) {\n    const key = `${club.name.toLowerCase().trim()}_${club.address.toLowerCase().trim()}`;\n    if (!seen.has(key)) {\n      seen.add(key);\n      uniqueClubs.push(club);\n    }\n  }\n}\n\nconst elapsedMs = Date.now() - taskData.startTime;\nconsole.log(`Found ${uniqueClubs.length} unique clubs in ${taskData.data.city} (${elapsedMs}ms)`);\n\nreturn [{\n  json: {\n    taskId: taskData.taskId,\n    runId: taskData.data.runId,\n    city: taskData.data.city,\n    clubs: uniqueClubs,\n    totalFound: uniqueClubs.length,\n    errors,\n    elapsedMs,\n    timestamp: new Date().toISOString()\n  }\n}];"
      }
    },
    {
      "id": "save-results-batch-001",
      "name": "Save Results to Redis",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2260, 700],
      "parameters": {
        "functionCode": "// Prepare batch save operations\nconst operations = [];\nconst result = items[0].json;\n\n// Save summary\noperations.push({\n  operation: 'set',\n  key: `result:${result.taskId}`,\n  value: JSON.stringify({\n    taskId: result.taskId,\n    runId: result.runId,\n    city: result.city,\n    totalFound: result.totalFound,\n    errors: result.errors,\n    elapsedMs: result.elapsedMs,\n    timestamp: result.timestamp\n  }),\n  ttl: 86400 * 7\n});\n\n// Save each club\nfor (const club of result.clubs) {\n  const clubKey = `club:${result.city.replace(/\\s+/g, '_')}:${club.name.replace(/[^a-zA-Z0-9А-Яа-я]/g, '_')}`;\n  operations.push({\n    operation: 'set',\n    key: clubKey,\n    value: JSON.stringify(club),\n    ttl: 86400 * 30\n  });\n}\n\n// Add to processing set\noperations.push({\n  operation: 'sadd',\n  key: `clubs:${result.runId}:cities`,\n  value: result.city\n});\n\n// Return operations for batch processing\nreturn operations.map(op => ({ json: op }));"
      }
    },
    {
      "id": "redis-batch-save-001",
      "name": "Batch Save to Redis",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2460, 700],
      "parameters": {
        "operation": "set",
        "key": "={{ $json.key }}",
        "value": "={{ $json.value }}",
        "keyType": "automatic",
        "expire": "={{ !!$json.ttl }}",
        "ttl": "={{ $json.ttl || 86400 }}"
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    },
    {
      "id": "trigger-enrichment-batch-001",
      "name": "Trigger Enrichment Batch",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2660, 700],
      "parameters": {
        "functionCode": "// Get unique clubs from the batch save\nconst result = $node['Parse All Results'].json;\nconst enrichmentTasks = [];\n\n// Create enrichment tasks for each club\nfor (const club of result.clubs.slice(0, 20)) { // Limit to 20 per batch\n  enrichmentTasks.push({\n    taskId: `enrich_${result.taskId}_${club.name.replace(/[^a-zA-Z0-9]/g, '_')}`,\n    type: 'ENRICH_CONTACT_INFO',\n    priority: club.isChain ? 1 : 2,\n    data: {\n      club,\n      runId: result.runId,\n      parentTaskId: result.taskId\n    }\n  });\n}\n\nreturn enrichmentTasks.map(task => ({ json: task }));"
      }
    },
    {
      "id": "queue-enrichment-tasks-001",
      "name": "Queue Enrichment Tasks",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2860, 700],
      "parameters": {
        "operation": "push",
        "list": "queue:enrichment:tasks",
        "messageData": "={{ JSON.stringify($json) }}",
        "tail": true
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    },
    {
      "id": "complete-task-001",
      "name": "Complete Task",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [3060, 700],
      "parameters": {
        "functionCode": "const result = $node['Parse All Results'].json;\nconst enrichmentCount = $input.all().length;\n\nconst completion = {\n  taskId: result.taskId,\n  runId: result.runId,\n  city: result.city,\n  status: 'completed',\n  clubsFound: result.totalFound,\n  enrichmentTasksQueued: enrichmentCount,\n  elapsedMs: result.elapsedMs,\n  completedAt: new Date().toISOString()\n};\n\nconsole.log(`Task ${completion.taskId} completed: ${completion.clubsFound} clubs, ${completion.enrichmentTasksQueued} enrichment tasks`);\n\nreturn [{ json: completion }];"
      }
    },
    {
      "id": "save-completion-001",
      "name": "Save Completion Status",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [3260, 700],
      "parameters": {
        "operation": "set",
        "key": "={{ `task:completed:${$json.taskId}` }}",
        "value": "={{ JSON.stringify($json) }}",
        "keyType": "automatic",
        "expire": true,
        "ttl": 604800
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    },
    {
      "id": "error-trigger-001",
      "name": "Error Trigger",
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [260, 900],
      "parameters": {}
    },
    {
      "id": "handle-error-001",
      "name": "Handle Error",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [460, 900],
      "parameters": {
        "functionCode": "const error = $json.error;\nconst taskData = $node['Parse Task Data']?.json || {};\n\nconst errorRecord = {\n  workflow: 'WF-01 Fetch Gaming Clubs',\n  taskId: taskData.taskId || 'unknown',\n  city: taskData.data?.city || 'unknown',\n  timestamp: new Date().toISOString(),\n  error: error?.message || 'Unknown error',\n  node: error?.node?.name || 'Unknown',\n  retries: taskData.retries || 0,\n  maxRetries: taskData.maxRetries || 3\n};\n\nconsole.error('WF-01 Error:', errorRecord);\n\n// Check if we should retry\nconst shouldRetry = errorRecord.retries < errorRecord.maxRetries;\n\nreturn [{\n  json: {\n    ...errorRecord,\n    shouldRetry,\n    nextRetry: shouldRetry ? errorRecord.retries + 1 : null\n  }\n}];"
      }
    },
    {
      "id": "check-retry-001",
      "name": "Should Retry?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [660, 900],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "shouldRetry",
              "leftValue": "={{ $json.shouldRetry }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      }
    },
    {
      "id": "requeue-task-001",
      "name": "Requeue Task",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [860, 800],
      "parameters": {
        "functionCode": "const errorData = items[0].json;\nconst originalTask = $node['Parse Task Data']?.json || {};\n\n// Create retry task with exponential backoff\nconst retryTask = {\n  ...originalTask,\n  retries: errorData.nextRetry,\n  retryDelay: Math.pow(2, errorData.nextRetry) * 1000,\n  lastError: errorData.error,\n  lastErrorAt: errorData.timestamp\n};\n\nreturn [{ json: retryTask }];"
      }
    },
    {
      "id": "wait-before-retry-001",
      "name": "Wait Before Retry",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [1060, 800],
      "parameters": {
        "amount": "={{ Math.min($json.retryDelay / 1000, 300) }}",
        "unit": "seconds"
      }
    },
    {
      "id": "push-retry-queue-001",
      "name": "Push to Retry Queue",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1260, 800],
      "parameters": {
        "operation": "push",
        "list": "queue:gaming_clubs:tasks",
        "messageData": "={{ JSON.stringify($json) }}",
        "tail": true
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    },
    {
      "id": "save-error-001",
      "name": "Save Error",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [860, 1000],
      "parameters": {
        "operation": "set",
        "key": "={{ `error:fetch:${$json.taskId}:${Date.now()}` }}",
        "value": "={{ JSON.stringify($json) }}",
        "keyType": "automatic",
        "expire": true,
        "ttl": 86400
      },
      "credentials": {
        "redis": {
          "id": "REDIS_INTERNAL",
          "name": "Redis Internal"
        }
      }
    }
  ],
  "connections": {
    "Redis Queue Trigger": {
      "main": [[{"node": "Merge Triggers", "type": "main", "index": 0}]]
    },
    "Manual Trigger": {
      "main": [[{"node": "Merge Triggers", "type": "main", "index": 1}]]
    },
    "Merge Triggers": {
      "main": [[{"node": "Parse Task Data", "type": "main", "index": 0}]]
    },
    "Parse Task Data": {
      "main": [[{"node": "Initial Rate Limit", "type": "main", "index": 0}]]
    },
    "Initial Rate Limit": {
      "main": [[
        {"node": "Fetch Yandex Maps", "type": "main", "index": 0},
        {"node": "Prepare 2GIS Request", "type": "main", "index": 0}
      ]]
    },
    "Fetch Yandex Maps": {
      "main": [[{"node": "Merge All Results", "type": "main", "index": 0}]]
    },
    "Prepare 2GIS Request": {
      "main": [[{"node": "2GIS Pagination Loop", "type": "main", "index": 0}]]
    },
    "2GIS Pagination Loop": {
      "main": [
        [{"node": "Fetch 2GIS Page", "type": "main", "index": 0}],
        [{"node": "Merge All Results", "type": "main", "index": 1}]
      ]
    },
    "Fetch 2GIS Page": {
      "main": [[{"node": "Process 2GIS Response", "type": "main", "index": 0}]]
    },
    "Process 2GIS Response": {
      "main": [[{"node": "Wait Rate Limit", "type": "main", "index": 0}]]
    },
    "Wait Rate Limit": {
      "main": [[{"node": "2GIS Pagination Loop", "type": "main", "index": 0}]]
    },
    "Merge All Results": {
      "main": [[{"node": "Parse All Results", "type": "main", "index": 0}]]
    },
    "Parse All Results": {
      "main": [[{"node": "Save Results to Redis", "type": "main", "index": 0}]]
    },
    "Save Results to Redis": {
      "main": [[{"node": "Batch Save to Redis", "type": "main", "index": 0}]]
    },
    "Batch Save to Redis": {
      "main": [[{"node": "Trigger Enrichment Batch", "type": "main", "index": 0}]]
    },
    "Trigger Enrichment Batch": {
      "main": [[{"node": "Queue Enrichment Tasks", "type": "main", "index": 0}]]
    },
    "Queue Enrichment Tasks": {
      "main": [[{"node": "Complete Task", "type": "main", "index": 0}]]
    },
    "Complete Task": {
      "main": [[{"node": "Save Completion Status", "type": "main", "index": 0}]]
    },
    "Error Trigger": {
      "main": [[{"node": "Handle Error", "type": "main", "index": 0}]]
    },
    "Handle Error": {
      "main": [[{"node": "Should Retry?", "type": "main", "index": 0}]]
    },
    "Should Retry?": {
      "main": [
        [{"node": "Requeue Task", "type": "main", "index": 0}],
        [{"node": "Save Error", "type": "main", "index": 0}]
      ]
    },
    "Requeue Task": {
      "main": [[{"node": "Wait Before Retry", "type": "main", "index": 0}]]
    },
    "Wait Before Retry": {
      "main": [[{"node": "Push to Retry Queue", "type": "main", "index": 0}]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "executionTimeout": 600
  },
  "version": 2,
  "id": "wf-01-fetch-gaming-clubs",
  "meta": {
    "templateCredsSetupCompleted": true,
    "description": "Fetches gaming clubs with Redis Queue, pagination, retry logic, and error handling",
    "version": "1.0.0"
  },
  "tags": [
    {
      "id": "1",
      "name": "production"
    }
  ]
}